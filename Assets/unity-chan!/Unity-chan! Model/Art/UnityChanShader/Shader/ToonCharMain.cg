// Character shader
// Upgrade NOTE: excluded shader from DX11, OpenGL ES 2.0 because it uses unsized arrays
#pragma exclude_renderers d3d11 gles
// Includes falloff shadow and specular, reflection, and normal mapping

#define ENABLE_CAST_SHADOWS

// Material parameters
float4 _Color;
float4 _ShadowColor;
float4 _LightColor0;
float _SpecularPower;
float4 _MainTex_ST;

float _TextureColorModifier;
float _RimLightIntensity;
float _HighLightIntensity;

// Textures
sampler2D _MainTex;
sampler2D _FalloffSampler;
sampler2D _RimLightSampler;
sampler2D _SpecularReflectionSampler;
sampler2D _EnvMapSampler;
sampler2D _NormalMapSampler;

// Constants
#define FALLOFF_POWER 0.3

#ifdef ENABLE_CAST_SHADOWS

// Structure from vertex shader to fragment shader
struct v2f
{
	float4 pos      : SV_POSITION;
	LIGHTING_COORDS( 0, 1 )
	float2 uv       : TEXCOORD2;
	float3 eyeDir   : TEXCOORD3;
	float3 lightDir : TEXCOORD4;
	float3 normal   : TEXCOORD5;
#ifdef ENABLE_NORMAL_MAP
	float3 tangent  : TEXCOORD6;
	float3 binormal : TEXCOORD7;
#endif
};

#else

// Structure from vertex shader to fragment shader
struct v2f
{
	float4 pos      : SV_POSITION;
	float2 uv       : TEXCOORD0;
	float3 eyeDir   : TEXCOORD1;
	float3 lightDir : TEXCOORD2;
	float3 normal   : TEXCOORD3;
#ifdef ENABLE_NORMAL_MAP
	float3 tangent  : TEXCOORD4;
	float3 binormal : TEXCOORD5;
#endif
};

#endif

// Float types
#define float_t    half
#define float2_t   half2
#define float3_t   half3
#define float4_t   half4
#define float3x3_t half3x3

// Vertex shader
v2f vert( appdata_tan v )
{
	v2f o;
	o.pos = UnityObjectToClipPos( v.vertex );
	o.uv.xy = TRANSFORM_TEX( v.texcoord.xy, _MainTex );
	o.normal = normalize( mul( unity_ObjectToWorld, float4_t( v.normal, 0 ) ).xyz );
	
	// Eye direction vector
	half4 worldPos = mul( unity_ObjectToWorld, v.vertex );
	o.eyeDir.xyz = normalize( _WorldSpaceCameraPos.xyz - worldPos.xyz ).xyz;
	o.lightDir = WorldSpaceLightDir( v.vertex );
	
#ifdef ENABLE_NORMAL_MAP	
	// Binormal and tangent (for normal map)
	o.tangent = normalize( mul( unity_ObjectToWorld, float4_t( v.tangent.xyz, 0 ) ).xyz );
	o.binormal = normalize( cross( o.normal, o.tangent ) * v.tangent.w );
#endif

#ifdef ENABLE_CAST_SHADOWS
	TRANSFER_VERTEX_TO_FRAGMENT( o );
#endif

	return o;
}

// Overlay blend
inline float3_t GetOverlayColor( float3_t inUpper, float3_t inLower )
{
	float3_t oneMinusLower = float3_t( 1.0, 1.0, 1.0 ) - inLower;
	float3_t valUnit = 2.0 * oneMinusLower;
	float3_t minValue = 2.0 * inLower - float3_t( 1.0, 1.0, 1.0 );
	float3_t greaterResult = inUpper * valUnit + minValue;

	float3_t lowerResult = 2.0 * inLower * inUpper;

	half3 lerpVals = round(inLower);
	return lerp(lowerResult, greaterResult, lerpVals);
}

#ifdef ENABLE_NORMAL_MAP

// Compute normal from normal map
inline float3_t GetNormalFromMap( v2f input )
{
	float3_t normalVec = normalize( tex2D( _NormalMapSampler, input.uv ).xyz * 2.0 - 1.0 );
	float3x3_t localToWorldTranspose = float3x3_t(
		input.tangent,
		input.binormal,
		input.normal
	);
	
	normalVec = normalize( mul( normalVec, localToWorldTranspose ) );
	return normalVec;
}

#endif

// Fragment shader
float4 frag( v2f i ) : COLOR
{
    float4_t diffSamplerColor = tex2D( _MainTex, i.uv.xy);

    float4_t largeValue = diffSamplerColor.r > diffSamplerColor.g ? diffSamplerColor.r : diffSamplerColor.g;
    largeValue = largeValue > diffSamplerColor.b ? largeValue : diffSamplerColor.b;
    
    float4_t textureColor = diffSamplerColor + clamp((diffSamplerColor / diffSamplerColor.r + diffSamplerColor / diffSamplerColor.g)/2,0,1) * (1 - diffSamplerColor.z);
    
    float4_t cleanColor = textureColor * (largeValue + (1 - diffSamplerColor.z) * largeValue)/2;
    
    textureColor = cleanColor * float4_t(1.5,1,1,1);
    
#ifdef ENABLE_NORMAL_MAP
	float3_t normalVec = GetNormalFromMap( i );
#else
	float3_t normalVec = i.normal;
#endif

	// Falloff. Convert the angle between the normal and the camera direction into a lookup for the gradient
	float_t normalDotEye = dot( normalVec, i.eyeDir.xyz );
	float_t falloffU = clamp( 1.0 - abs( normalDotEye ), 0.02, 0.98 );

	// Rimlight
	
	float4_t Lambert = dot(normalVec,i.lightDir);
	float4_t halfLambert = Lambert / 2 + 0.5;
	
	float4_t spColor = tex2D(_SpecularReflectionSampler, i.uv);
	float4_t spLambert = dot(spColor,i.lightDir);
	
	float_t rimlightDot = saturate( _RimLightIntensity * (halfLambert + 0.5));
	falloffU = saturate( rimlightDot * falloffU );
	falloffU = tex2D( _RimLightSampler, float2( falloffU, 0.25f )).r;
	float3_t lightColor = textureColor.rgb * falloffU;

    float4_t stairLight = clamp(floor(rimlightDot * 2)/2,0.6,1);
    
    if(halfLambert.z < spLambert.z){
        stairLight *= 0.25;
    }
    
    float4_t highLight = clamp(floor(float4_t(lightColor,1).z * _HighLightIntensity), 0, 1);

    return textureColor * stairLight + highLight;
}
